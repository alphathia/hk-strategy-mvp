"""
Signal Dictionary - Centralized Signal Type Management System
Comprehensive metadata and management for all signal types, events, and configurations
"""

from typing import Dict, List, Any, Optional, Tuple, Set
from enum import Enum
from dataclasses import dataclass
from datetime import datetime, date
import re
import json

class SignalType(Enum):
    STRATEGIC = "strategic"      # TXYZn strategic signals
    ALERT = "alert"             # Price/volume alerts
    TECHNICAL = "technical"     # Technical indicator signals
    FUNDAMENTAL = "fundamental" # Fundamental analysis signals
    SENTIMENT = "sentiment"     # Market sentiment signals

class SignalPriority(Enum):
    LOW = 1
    MEDIUM = 2  
    HIGH = 3
    CRITICAL = 4

class SignalStatus(Enum):
    ACTIVE = "active"
    INACTIVE = "inactive"
    EXPIRED = "expired"
    TRIGGERED = "triggered"

@dataclass
class SignalDefinition:
    """Complete definition for a signal type"""
    signal_id: str
    name: str
    description: str
    signal_type: SignalType
    category: str
    
    # Format and validation
    format_pattern: str         # Regex pattern for signal format
    format_example: str         # Example of valid format
    validation_rules: List[str] # Validation rule descriptions
    
    # Metadata
    priority: SignalPriority
    supports_strength: bool     # Whether signal supports 1-9 strength levels
    supports_provisional: bool  # Whether signal can be provisional
    
    # Parameters
    default_parameters: Dict[str, Any]
    parameter_schema: Dict[str, Dict]  # JSON schema for parameters
    
    # Display properties
    color_mapping: Dict[str, str]  # Colors for different values/strengths
    icon: str
    display_format: str            # Template for display format
    
    # Documentation
    usage_notes: str
    examples: List[str]
    related_signals: List[str]
    
    # System properties
    is_active: bool
    created_at: datetime
    updated_at: datetime

class SignalDictionary:
    """
    Centralized signal dictionary managing all signal types,
    formats, validation rules, and metadata
    """
    
    # ==============================================
    # Signal Type Definitions
    # ==============================================
    
    SIGNAL_DEFINITIONS = {
        # Strategic TXYZn Signals
        "strategic_signal": SignalDefinition(
            signal_id="strategic_signal",
            name="Strategic TXYZn Signal",
            description="Professional strategic trading signal with 5-character TXYZn format",
            signal_type=SignalType.STRATEGIC,
            category="trading",
            
            format_pattern=r'^[BS][A-Z]{3}[1-9]$',
            format_example="BBRK7",
            validation_rules=[
                "Must start with B (Buy) or S (Sell)",
                "Followed by 3 uppercase letters (strategy code)",
                "End with single digit 1-9 (strength level)",
                "Total length must be exactly 5 characters"
            ],
            
            priority=SignalPriority.HIGH,
            supports_strength=True,
            supports_provisional=True,
            
            default_parameters={
                "min_strength": 1,
                "max_strength": 9,
                "provisional_timeout_minutes": 30,
                "auto_confirm_threshold": 7
            },
            
            parameter_schema={
                "min_strength": {
                    "type": "integer",
                    "minimum": 1,
                    "maximum": 9,
                    "description": "Minimum signal strength to display"
                },
                "max_strength": {
                    "type": "integer", 
                    "minimum": 1,
                    "maximum": 9,
                    "description": "Maximum signal strength to display"
                },
                "provisional_timeout_minutes": {
                    "type": "integer",
                    "minimum": 5,
                    "maximum": 120,
                    "description": "Minutes before provisional signal expires"
                }
            },
            
            color_mapping={
                "B1-B3": "#90EE90",   # Light green for weak buy
                "B4-B6": "#32CD32",   # Lime green for moderate buy
                "B7-B9": "#006400",   # Dark green for strong buy
                "S1-S3": "#FFB6C1",   # Light pink for weak sell
                "S4-S6": "#FF1493",   # Deep pink for moderate sell  
                "S7-S9": "#DC143C"    # Crimson for strong sell
            },
            
            icon="target",
            display_format="{action}{base_strategy}{strength}",
            
            usage_notes="""
            Strategic signals are the primary trading signals generated by the system.
            They provide directional bias (Buy/Sell) with strength indication (1-9).
            Use provisional signals for real-time monitoring, confirmed signals for trading.
            """,
            
            examples=["BBRK9", "SOBR3", "BMAC7", "SRES5"],
            related_signals=["price_alert", "volume_alert"],
            
            is_active=True,
            created_at=datetime.now(),
            updated_at=datetime.now()
        ),
        
        # Price Alerts
        "price_alert": SignalDefinition(
            signal_id="price_alert",
            name="Price Alert",
            description="Price-based alert when security reaches specified levels",
            signal_type=SignalType.ALERT,
            category="monitoring",
            
            format_pattern=r'^P[ABRUD][0-9]+(\.[0-9]+)?$',
            format_example="PA125.50",
            validation_rules=[
                "Must start with P (Price)",
                "Followed by alert type: A(Above), B(Below), R(Range), U(Up%), D(Down%)",
                "Followed by numeric price/percentage value"
            ],
            
            priority=SignalPriority.MEDIUM,
            supports_strength=False,
            supports_provisional=False,
            
            default_parameters={
                "alert_tolerance": 0.001,    # 0.1% tolerance
                "auto_disable_on_trigger": True,
                "notification_enabled": True
            },
            
            parameter_schema={
                "alert_tolerance": {
                    "type": "number",
                    "minimum": 0.0001,
                    "maximum": 0.05,
                    "description": "Tolerance for price alert triggering"
                },
                "auto_disable_on_trigger": {
                    "type": "boolean",
                    "description": "Automatically disable alert after triggering"
                }
            },
            
            color_mapping={
                "PA": "#FFA500",  # Orange for above
                "PB": "#FF4500",  # Red orange for below
                "PR": "#9370DB",  # Medium orchid for range
                "PU": "#32CD32",  # Lime green for up%
                "PD": "#FF6347"   # Tomato for down%
            },
            
            icon="bell",
            display_format="Price {alert_type} {value}",
            
            usage_notes="""
            Price alerts notify when securities reach specified price levels.
            Use for monitoring breakout levels, stop losses, or target prices.
            """,
            
            examples=["PA150.00", "PB95.50", "PU5.0", "PD10.0"],
            related_signals=["strategic_signal", "volume_alert"],
            
            is_active=True,
            created_at=datetime.now(),
            updated_at=datetime.now()
        ),
        
        # Volume Alerts
        "volume_alert": SignalDefinition(
            signal_id="volume_alert",
            name="Volume Alert", 
            description="Volume-based alert for unusual trading activity",
            signal_type=SignalType.ALERT,
            category="monitoring",
            
            format_pattern=r'^V[AHLU][0-9]+(\.[0-9]+)?$',
            format_example="VA2.5",
            validation_rules=[
                "Must start with V (Volume)",
                "Followed by alert type: A(Above ratio), H(High), L(Low), U(Unusual)",
                "Followed by numeric ratio or threshold value"
            ],
            
            priority=SignalPriority.MEDIUM,
            supports_strength=False,
            supports_provisional=False,
            
            default_parameters={
                "volume_threshold": 2.0,      # 2x average volume
                "lookback_periods": 20,       # 20-day average
                "notification_enabled": True
            },
            
            parameter_schema={
                "volume_threshold": {
                    "type": "number",
                    "minimum": 1.0,
                    "maximum": 10.0, 
                    "description": "Multiple of average volume to trigger alert"
                },
                "lookback_periods": {
                    "type": "integer",
                    "minimum": 5,
                    "maximum": 50,
                    "description": "Number of periods for volume average calculation"
                }
            },
            
            color_mapping={
                "VA": "#FFD700",  # Gold for above
                "VH": "#FF8C00",  # Dark orange for high
                "VL": "#4169E1",  # Royal blue for low
                "VU": "#DC143C"   # Crimson for unusual
            },
            
            icon="activity",
            display_format="Volume {alert_type} {threshold}x",
            
            usage_notes="""
            Volume alerts identify unusual trading activity that may precede
            significant price moves. Use with price action for confirmation.
            """,
            
            examples=["VA3.0", "VH5.0", "VU2.5"],
            related_signals=["strategic_signal", "price_alert"],
            
            is_active=True,
            created_at=datetime.now(),
            updated_at=datetime.now()
        ),
        
        # Technical Indicator Signals
        "technical_signal": SignalDefinition(
            signal_id="technical_signal",
            name="Technical Indicator Signal",
            description="Signal based on technical indicator thresholds and crossovers",
            signal_type=SignalType.TECHNICAL,
            category="analysis",
            
            format_pattern=r'^T[A-Z]{2,4}[XOBSU][0-9]*$',
            format_example="TRSIX70",
            validation_rules=[
                "Must start with T (Technical)",
                "Followed by 2-4 letter indicator code (RSI, MACD, etc.)",
                "Followed by signal type: X(Cross), O(Overbought), B(Oversold), S(Signal), U(Unusual)",
                "Optionally followed by numeric threshold value"
            ],
            
            priority=SignalPriority.LOW,
            supports_strength=False,
            supports_provisional=True,
            
            default_parameters={
                "rsi_overbought": 70,
                "rsi_oversold": 30,
                "macd_sensitivity": 0.001,
                "confirmation_required": True
            },
            
            parameter_schema={
                "rsi_overbought": {
                    "type": "number",
                    "minimum": 60,
                    "maximum": 90,
                    "description": "RSI overbought threshold"
                },
                "rsi_oversold": {
                    "type": "number",
                    "minimum": 10, 
                    "maximum": 40,
                    "description": "RSI oversold threshold"
                }
            },
            
            color_mapping={
                "TRSI": "#9370DB",   # Medium orchid for RSI
                "TMACD": "#20B2AA",  # Light sea green for MACD
                "TSTOCH": "#FF69B4", # Hot pink for Stochastic
                "TBOLL": "#DDA0DD"   # Plum for Bollinger
            },
            
            icon="trending-up",
            display_format="{indicator} {signal_type}",
            
            usage_notes="""
            Technical signals based on individual indicator thresholds.
            Use for supplementary analysis and confirmation of strategic signals.
            """,
            
            examples=["TRSIO30", "TMACX", "TSTOCHS", "TBOLLO"],
            related_signals=["strategic_signal"],
            
            is_active=True,
            created_at=datetime.now(),
            updated_at=datetime.now()
        ),
        
        # Legacy A/B/C/D Signals (for backward compatibility)
        "legacy_signal": SignalDefinition(
            signal_id="legacy_signal",
            name="Legacy A/B/C/D Signal",
            description="Legacy 4-tier signal system (deprecated, use strategic_signal)",
            signal_type=SignalType.STRATEGIC,
            category="legacy",
            
            format_pattern=r'^[ABCD]$',
            format_example="B",
            validation_rules=[
                "Must be single character: A, B, C, or D",
                "A = Strong Buy, B = Buy, C = Hold, D = Sell"
            ],
            
            priority=SignalPriority.LOW,
            supports_strength=False,
            supports_provisional=False,
            
            default_parameters={
                "auto_migrate_to_strategic": True,
                "migration_mapping": {
                    "A": "BMOM9",
                    "B": "BMOM7", 
                    "C": "HMOM5",
                    "D": "SMOM3"
                }
            },
            
            parameter_schema={
                "auto_migrate_to_strategic": {
                    "type": "boolean",
                    "description": "Automatically convert to strategic signals"
                }
            },
            
            color_mapping={
                "A": "#00C851",  # Green
                "B": "#33B679",  # Light green
                "C": "#FFB300",  # Orange
                "D": "#FF4444"   # Red
            },
            
            icon="archive",
            display_format="Legacy {signal}",
            
            usage_notes="""
            DEPRECATED: Legacy signal format maintained for backward compatibility.
            Use strategic_signal (TXYZn format) for new implementations.
            """,
            
            examples=["A", "B", "C", "D"],
            related_signals=["strategic_signal"],
            
            is_active=False,  # Deprecated
            created_at=datetime.now(),
            updated_at=datetime.now()
        )
    }
    
    # ==============================================
    # Signal Management Methods
    # ==============================================
    
    @classmethod
    def get_signal_definition(cls, signal_id: str) -> Optional[SignalDefinition]:
        """Get definition for a specific signal type"""
        return cls.SIGNAL_DEFINITIONS.get(signal_id)
    
    @classmethod
    def get_all_signal_definitions(cls) -> Dict[str, SignalDefinition]:
        """Get all signal definitions"""
        return cls.SIGNAL_DEFINITIONS.copy()
    
    @classmethod
    def get_active_signals(cls) -> Dict[str, SignalDefinition]:
        """Get only active (non-deprecated) signal definitions"""
        return {
            key: definition for key, definition in cls.SIGNAL_DEFINITIONS.items()
            if definition.is_active
        }
    
    @classmethod
    def get_signals_by_type(cls, signal_type: SignalType) -> Dict[str, SignalDefinition]:
        """Get signals filtered by type"""
        return {
            key: definition for key, definition in cls.SIGNAL_DEFINITIONS.items()
            if definition.signal_type == signal_type
        }
    
    @classmethod
    def get_signals_by_category(cls, category: str) -> Dict[str, SignalDefinition]:
        """Get signals filtered by category"""
        return {
            key: definition for key, definition in cls.SIGNAL_DEFINITIONS.items()
            if definition.category == category
        }
    
    @classmethod
    def validate_signal_format(cls, signal_id: str, signal_value: str) -> Tuple[bool, List[str]]:
        """Validate signal format according to its definition"""
        definition = cls.get_signal_definition(signal_id)
        if not definition:
            return False, [f"Unknown signal type: {signal_id}"]
        
        errors = []
        
        # Check format pattern
        if not re.match(definition.format_pattern, signal_value):
            errors.append(f"Signal '{signal_value}' does not match pattern '{definition.format_pattern}'")
            errors.append(f"Expected format like: {definition.format_example}")
        
        # Additional validation for strategic signals
        if signal_id == "strategic_signal":
            errors.extend(cls._validate_strategic_signal(signal_value))
        
        return len(errors) == 0, errors
    
    @classmethod
    def _validate_strategic_signal(cls, signal_value: str) -> List[str]:
        """Additional validation for strategic TXYZn signals"""
        errors = []
        
        if len(signal_value) != 5:
            errors.append("Strategic signal must be exactly 5 characters")
            return errors
        
        side = signal_value[0]
        base_strategy = signal_value[:4]
        try:
            strength = int(signal_value[4])
        except ValueError:
            errors.append("Last character must be a digit 1-9")
            return errors
        
        # Validate base strategy exists
        from src.strategy_dictionary import StrategyDictionary
        if not StrategyDictionary.get_strategy_metadata(base_strategy):
            errors.append(f"Unknown base strategy: {base_strategy}")
        
        # Validate side matches strategy
        strategy_metadata = StrategyDictionary.get_strategy_metadata(base_strategy)
        if strategy_metadata and strategy_metadata.side.value != side:
            errors.append(f"Side '{side}' does not match strategy '{base_strategy}' expected side")
        
        # Validate strength range
        if not (1 <= strength <= 9):
            errors.append("Strength must be between 1 and 9")
        
        return errors
    
    @classmethod
    def parse_signal(cls, signal_id: str, signal_value: str) -> Optional[Dict[str, Any]]:
        """Parse signal value into components"""
        definition = cls.get_signal_definition(signal_id)
        if not definition:
            return None
        
        is_valid, errors = cls.validate_signal_format(signal_id, signal_value)
        if not is_valid:
            return None
        
        # Parse based on signal type
        if signal_id == "strategic_signal":
            return cls._parse_strategic_signal(signal_value)
        elif signal_id == "price_alert":
            return cls._parse_price_alert(signal_value)
        elif signal_id == "volume_alert":
            return cls._parse_volume_alert(signal_value)
        elif signal_id == "technical_signal":
            return cls._parse_technical_signal(signal_value)
        
        return {"signal_value": signal_value}
    
    @classmethod
    def _parse_strategic_signal(cls, signal_value: str) -> Dict[str, Any]:
        """Parse strategic TXYZn signal"""
        return {
            "side": signal_value[0],
            "base_strategy": signal_value[:4],
            "strength": int(signal_value[4]),
            "is_buy": signal_value[0] == "B",
            "is_sell": signal_value[0] == "S"
        }
    
    @classmethod
    def _parse_price_alert(cls, signal_value: str) -> Dict[str, Any]:
        """Parse price alert signal"""
        alert_type = signal_value[1]
        value_str = signal_value[2:]
        
        try:
            value = float(value_str)
        except ValueError:
            value = 0.0
        
        return {
            "alert_type": alert_type,
            "value": value,
            "is_above": alert_type == "A",
            "is_below": alert_type == "B",
            "is_range": alert_type == "R",
            "is_percentage": alert_type in ["U", "D"]
        }
    
    @classmethod
    def _parse_volume_alert(cls, signal_value: str) -> Dict[str, Any]:
        """Parse volume alert signal"""
        alert_type = signal_value[1]
        value_str = signal_value[2:]
        
        try:
            ratio = float(value_str)
        except ValueError:
            ratio = 1.0
        
        return {
            "alert_type": alert_type,
            "ratio": ratio,
            "is_above": alert_type == "A",
            "is_high": alert_type == "H",
            "is_low": alert_type == "L",
            "is_unusual": alert_type == "U"
        }
    
    @classmethod
    def _parse_technical_signal(cls, signal_value: str) -> Dict[str, Any]:
        """Parse technical indicator signal"""
        # Find where signal type starts
        signal_types = ["X", "O", "B", "S", "U"]
        signal_type_idx = -1
        signal_type = ""
        
        for i, char in enumerate(signal_value[1:], 1):
            if char in signal_types:
                signal_type_idx = i
                signal_type = char
                break
        
        if signal_type_idx == -1:
            return {"error": "Invalid technical signal format"}
        
        indicator = signal_value[1:signal_type_idx]
        value_str = signal_value[signal_type_idx + 1:]
        
        try:
            threshold = float(value_str) if value_str else None
        except ValueError:
            threshold = None
        
        return {
            "indicator": indicator,
            "signal_type": signal_type,
            "threshold": threshold,
            "is_crossover": signal_type == "X",
            "is_overbought": signal_type == "O",
            "is_oversold": signal_type == "B"
        }
    
    @classmethod
    def get_signal_color(cls, signal_id: str, signal_value: str) -> str:
        """Get display color for signal"""
        definition = cls.get_signal_definition(signal_id)
        if not definition:
            return "#666666"  # Default gray
        
        # Strategic signal color logic
        if signal_id == "strategic_signal":
            parsed = cls._parse_strategic_signal(signal_value)
            side = parsed["side"]
            strength = parsed["strength"]
            
            if side == "B":  # Buy signals
                if 1 <= strength <= 3:
                    return definition.color_mapping["B1-B3"]
                elif 4 <= strength <= 6:
                    return definition.color_mapping["B4-B6"]
                else:
                    return definition.color_mapping["B7-B9"]
            else:  # Sell signals
                if 1 <= strength <= 3:
                    return definition.color_mapping["S1-S3"]
                elif 4 <= strength <= 6:
                    return definition.color_mapping["S4-S6"]
                else:
                    return definition.color_mapping["S7-S9"]
        
        # Other signal types - use direct mapping or default
        for key in definition.color_mapping:
            if key in signal_value:
                return definition.color_mapping[key]
        
        return "#666666"  # Default gray
    
    @classmethod
    def get_signal_display_text(cls, signal_id: str, signal_value: str, 
                               context: Dict[str, Any] = None) -> str:
        """Get formatted display text for signal"""
        definition = cls.get_signal_definition(signal_id)
        if not definition:
            return signal_value
        
        parsed = cls.parse_signal(signal_id, signal_value)
        if not parsed:
            return signal_value
        
        try:
            return definition.display_format.format(**parsed, **(context or {}))
        except (KeyError, ValueError):
            return signal_value
    
    @classmethod
    def create_custom_signal_definition(cls, signal_data: Dict[str, Any]) -> SignalDefinition:
        """Create a new custom signal definition"""
        return SignalDefinition(
            signal_id=signal_data["signal_id"],
            name=signal_data["name"],
            description=signal_data["description"],
            signal_type=SignalType(signal_data["signal_type"]),
            category=signal_data["category"],
            format_pattern=signal_data["format_pattern"],
            format_example=signal_data["format_example"],
            validation_rules=signal_data.get("validation_rules", []),
            priority=SignalPriority(signal_data.get("priority", SignalPriority.MEDIUM.value)),
            supports_strength=signal_data.get("supports_strength", False),
            supports_provisional=signal_data.get("supports_provisional", False),
            default_parameters=signal_data.get("default_parameters", {}),
            parameter_schema=signal_data.get("parameter_schema", {}),
            color_mapping=signal_data.get("color_mapping", {}),
            icon=signal_data.get("icon", "signal"),
            display_format=signal_data.get("display_format", "{signal_value}"),
            usage_notes=signal_data.get("usage_notes", ""),
            examples=signal_data.get("examples", []),
            related_signals=signal_data.get("related_signals", []),
            is_active=signal_data.get("is_active", True),
            created_at=datetime.now(),
            updated_at=datetime.now()
        )
    
    @classmethod
    def get_dashboard_config(cls) -> Dict[str, Any]:
        """Get configuration for dashboard management"""
        return {
            "signal_types": [st.value for st in SignalType],
            "signal_priorities": [sp.value for sp in SignalPriority],
            "signal_statuses": [ss.value for ss in SignalStatus],
            "total_signal_definitions": len(cls.SIGNAL_DEFINITIONS),
            "active_signal_definitions": len(cls.get_active_signals()),
            "categories": list(set(defn.category for defn in cls.SIGNAL_DEFINITIONS.values())),
            "validation_patterns": {
                sid: defn.format_pattern 
                for sid, defn in cls.SIGNAL_DEFINITIONS.items()
            }
        }
    
    @classmethod
    def get_signal_summary(cls) -> Dict[str, Any]:
        """Get comprehensive signal system summary"""
        active_signals = cls.get_active_signals()
        
        summary = {
            "total_definitions": len(cls.SIGNAL_DEFINITIONS),
            "active_definitions": len(active_signals),
            "by_type": {},
            "by_category": {},
            "supports_strength": [],
            "supports_provisional": []
        }
        
        # Group by type
        for signal_type in SignalType:
            type_signals = cls.get_signals_by_type(signal_type)
            summary["by_type"][signal_type.value] = {
                "count": len(type_signals),
                "signal_ids": list(type_signals.keys())
            }
        
        # Group by category
        categories = set(defn.category for defn in active_signals.values())
        for category in categories:
            category_signals = cls.get_signals_by_category(category)
            summary["by_category"][category] = {
                "count": len(category_signals),
                "signal_ids": list(category_signals.keys())
            }
        
        # Feature support
        for sid, defn in active_signals.items():
            if defn.supports_strength:
                summary["supports_strength"].append(sid)
            if defn.supports_provisional:
                summary["supports_provisional"].append(sid)
        
        return summary

# Usage example
if __name__ == "__main__":
    # Example usage
    signal_dict = SignalDictionary()
    
    # Validate strategic signal
    is_valid, errors = signal_dict.validate_signal_format("strategic_signal", "BBRK7")
    print(f"BBRK7 valid: {is_valid}, errors: {errors}")
    
    # Parse strategic signal
    parsed = signal_dict.parse_signal("strategic_signal", "BBRK7")
    print(f"BBRK7 parsed: {parsed}")
    
    # Get signal color
    color = signal_dict.get_signal_color("strategic_signal", "BBRK7")
    print(f"BBRK7 color: {color}")
    
    # Get dashboard config
    config = signal_dict.get_dashboard_config()
    print(f"Dashboard config: {list(config.keys())}")